### 数据结构和算法
- [怎么才算真正掌握了一个数据结构或算法？](https://mp.weixin.qq.com/s/t8z4KQMrTrR3NljtWJm2zg)
#### 1. AC自动机
- ac自动机是著名的多模式匹配算法，建立在字典树，KMP算法之上
  > 1. 字典树
  >> - 单词查找树，Trie树，是一种树形结构，根节点不包含字符，除根节点外每一个节点都只包含一个字符；  
  > 2. KMP算法,字符串匹配算法 时间复杂度O(m+n)
  >> - 核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。
  >> - 根据模式串最长公共前后缀，算出next数组，减少算法中i回溯所进行的无谓操作
- 构建分为三个步骤
  > 1. 将多个模式串构建成 Trie 树；
  > 2. 在 Trie 树上构建失败指针(bfs广度优先，给每个节点添加back节点);
  > 3. 模式匹配
  ```javascript
  //构建字典树
  function buildTree(words){
    let root = {
        child: {},      //子节点
        val: null,      //节点值
        back: null,     //fail之后的回溯节点
        parent: null,   //父节点
        accept: []      //都是是单词的结尾
    }
    //添加每一个word到root
    for(let word of words){
        addWord(root, p);
    }
    
    //添加fail之后的回溯节点
    fallbackAll(root);
    return root;
}
//添加一个模式串到字典树
function addWord(root, word){
    let current = root;
    for(let i=0;i<word.length;i++){
        let w = word[i];
        let child = current.child[w];
        if(!child){
            current.child[w] = {
                child: [],
                val: w,
                back: root,
                parent: current,
                accpet: []
            }
        }
        current = current.child[w];
    }
    //标记当前单词的长度
    current.accpet = [word.length];
}
//添加回溯，广度优先遍历给每个节点添加back节点
function fallbackAll(root){

    let curExpands = Object.values(root);
    while(curExpands.length>0){
        let nextExpands = [];//下一层的全部节点
        for(let node of curExpands){
            nextExpands.push(...Object.values(node.child));//添加当前节点的所有的子节点
            let parent = node.parent;//当前节点的父节点
            let back = parent.back;//父节点的back;
            while(back !== null){
                let child = back.child[node.val];//匹配父节点跳跃节点的子节点
                if(child){
                    node.back = child;
                    break;
                }
                back = back.back; //相当于 再找上一级
            }
        }

        curExpands = nextExpands; //下一层赋值给cur 
    }   

}

//添加单个回溯，新加的一个单词的back;
function fallbackOne(root, word){
    //首个个节点不用找，
    let node = root.child[word[0]];
    for(let i=1; i<word.length; i++){
        let w = word[i];                
        let parent = node.parent;
        let back = parent.back;
        while(back != null){
            let child = back.child[node.val];
            if(child){
                node.back = child;
                break;
            }
            back = back.back;
        }
        node = node.child[w];
    }
}
class FastScanner{
    constructor(words){
        this.root = buildTree(words);
    }
    add(){
        var word = word.trim();
        if(word.length === 0){
            return;
        }
        //添加单词到字典树
        addWord(this.root, word);
        //新添加的单词的fail
        fallback(this.root, word);
    }
    search(){

    }
}  
  ```

