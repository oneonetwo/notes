[待完善](https://blog.csdn.net/qq_38643059/article/details/89207861)
##### 1. jQuery框架简单实现
  ```javascript
      var jQuery = window.$ = function(sel){
          return new jQuery.fn.init(sel);
      };
      jQuery.fn = jQuery.prototype = {
        init: function(sel){
            //把dom对象变成 jQuery对象
            Array.prototype.push.apply(this, document.querySelectorAll(sel));
            return this;
        },
        name: 'jQuery'
      }
      /*jQuery 的方式是通过原型传递解决问题，把 jQuery 的原型传递给jQuery.prototype.init.prototype
      所以通过这个方法生成的实例 this 所指向的仍然是 jQuery.fn，所以能正确访问 jQuery 类原型上的属性与方法*/
      jQuery.fn.init.prototype = jQuery.fn;

      //添加扩展方法
      jQuery.extend = jQuery.fn.extend = function(){
          for(let p in arguments[0]){
              this[p] = arguments[0][i];
          }
      }
      //$('#logo-default')
        init {0: div#logo-default, length: 1}
  ```
##### 2. 设计模式相关
- 发布-订阅模式是面向调度中心编程的，而观察者模式则是面向目标和观察者编程的。发布订阅模式相比观察者模式多了个事件通道，订阅者和发布者不是直接关联的
> 1. 自定义事件（发布订阅模式）
  ```javascript
      // 自定义事件
      class EventObserver{
          constructor(){
              //不同type的函数的数组
              this.handleFun = [];
          }
          //添加type类型的函数
          add (...args){
              let [type, func] = args;
              this.handleFun[type] ? null : this.handleFun[type] = [];
              if(this.handleFun[type].includes(func)){
                  return;
              }else{
                  this.handleFun[type].push(func);
              }        
          }
          //移除type类型的函数
          remove (...args){
              let [type, func] = args;
              try{
                  let ind = this.handleFun[type].indexOf(func);
                  if(ind === -1){
                      throw new Error('function 不存在')
                  }else{
                      this.handleFun[type].splice(ind, 1);
                  }
              }catch(err){
                  console.log(err);
              }
          }
          emit (...args){
              //可能是多个参数，type或者指定的出发函数
              try{
                  let [type, func] = args;
                  if(func){
                      this.handleFun[type].forEach(item=>{
                          item();
                      }) 
                  }else{
                      let ind = this.handleFun[type].indexOf(func);
                      if(ind === -1){
                          throw new Error('function 不存在')
                      }else{
                          this.handleFun[type][index]();
                      } 
                  }

              }catch(err){
                  console.log(err);
              }
          }
          once (...args) {
              //就是在触发后，移除它
              this.emit(...args)?this.remove(...args):null;
          }
      }
      //用法示例
      let btn1 = document.getElementById("test1");
      let eventObs = new EventObserver();

      function handler1(){
          alert("handler1:");
      };

      function handler2(){
          alert("handler2:");
      };

      //订阅       
      eventObs.add("msgType", handler1);
      eventObs.add("msgType", handler2);


      //点击按钮触发发布消息（触发事件）    
      btn1.addEventListener("click",  function(){
          etarget.emit("msgType");
      }, false);

  ```
> 2. 观察者模式
  ```javascript
      //观察者模式
      //主题
      class Subject{
          constructor(){
              this._state = 0;
              this._observers = [];
          }

          getState(){
              return this._state;
          }

          setState(val){
              this._state = val;
              this.notifyAllObservers(this._state);
          }
          attch(obs){
              this._observers.push(obs);
          }
          notifyAllObservers(value){
              this._observers.forEach(item=>{
                  item.update(value);
              })
          }

      }
      //订阅
      class Observer{
          constructor(sub){
              this._subject = sub;
              this._subject.attch(this);
          }
          update(val){
              console.log('主题更新了:', val);
          }
      }
      let sub = new Subject();
      let ob1 = new Observer(sub);
      let ob2 = new Observer(sub);
      sub.setState(4);  
  ```
##### 4. 函数柯里化
##### 5. 函数防抖、函数节流
##### 6. call,apply,bind的封装实现
> 1. call 改变了this,然后把调用的函数在当前上下文中执行了一遍；参数是单个的
> 2. apply 参数是个数组
> 3. bind

  ```javascript
    Function.prototype.call = function(context,...args){
        if(!context){
           context = window;
        }
        let symbol = Symbol();
        context[symbol] = this;
        let fn = context[symbol](...args);
        delete context[symbol];
        return fn;
    } 
    
    Function.prototype.apply = function(context, args){
        if(!context){
           context = window;
        }
        let symbol = Symbol();
        context[symbol] = this;
        let fn = context[symbol](...args);
        delete context[symbol];
        return fn;        
    }
    Function.prototype.bind = function(context){
        if(!context){
           context = window;
        }
        self = this;
        return function(...args){
            self.apply(context, args)
        }
    }
  ```
##### 7. new的实现
> 1. 创建一个空对象，把__proto__指向构造函数的原型，用apply获取构造函数的实例的方法，属性。返回这个对象。
  ```javascript
      function new(fn){
          return function(...args){
              let obj = {};
              obj.__proto__ = fn.prototype;
              fn.apply(obj,args);
              return obj;
          }
      }
  ```
##### 8. 深拷贝
  ```javascript
      function deepCopy(obj,newObj={}){
          for(let p in  obj){
              if(obj[p]&&typeof obj[p] === 'object'){
                  newObj[p] = obj[p].contructor === Object?deepCopy(obj[p]):deepCopy(obj[p],[])
              }else{
                  newObj[p] = obj[p];
              }
          }
          return newObj;
      }
  ```
##### 9. 查找字符串中出现最多的字符和个数
##### 10. 驼峰命名
##### 11. 驼峰命名
  - 处理cookie
  ```javascript
      var reg = /^(?=[A-z]{1})(?=.*[\d])(?=.*[\w])(?=.*[!@#$])[\d\w!@#$]{5}$/i
      document.cookie.match(new RegExp("(^| )"+name+"=([^;]*)(;|$)"));
  ```
