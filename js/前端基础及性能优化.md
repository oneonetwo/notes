### 一. Css基础
##### 1. 盒模型
1. 盒模型是 （content），margin（外边距）、border（边框）、padding（内边框）
	1. IE盒模型的width: border+padding+content;
	2. 标准盒模型width: content;
	3. 改变盒模型： (IE)box-sizing: border-box； (普通)box-sizing: content-box;
2. 几种获取元素宽度的区别
	1. clientWidth: 包括内边距，不包括垂直滚动条(如果有的话)、边框和外边框;
	2. offsetWidth: border,padding,width的总和;
	3. scrollWidth: 实际内容的宽度+padding;
##### 2. BFC
1. BFC（Block Formatting Context）格式化上下文
2. 形成条件
	1. float的值不为none
	2. overflow的值不为visible
	3. position的值不为static；
	4. display的值为inline-blcok,table-cell,table-caption;
	5. flex boxes
3. 布局规则
	1. BFC就是页面上的一个独立容器，容器里面的子元素不会影响到外面的元素
	2. 同一个BFC的两个相邻盒子的margin可能会发生重叠
	3. BFC的区域不会与float元素区域重叠
	4. 计算BFC的高度时，浮动子元素也参与计算
4. 应用
	1.	解决margin重叠问题
	2.	解决浮动问题
	3.	解决侵占浮动元素的问题
##### 3. css布局
1. 三列布局，左右宽度已知，中间元素自动敞开，6种方式 [查看代码](#css基础的三列布局)
	1. float 中间不设置宽度;
	2. position 中间不设置宽度;
	3. flex 弹性盒子，设置父元素`display：flex`，中间设置为`flex:1`;
	3. calc 中间设置 `width: calc(100% - 200px)`;
	4. table 表布局，中间不设置宽度
	5. gird 网格布局
2. 水平垂直居中
	1. 绝对定位+margin：auto
	2. 绝对定位+margin反向偏移 `margin-left: -100px;  margin-top: -75px; `
	3. 绝对定位+transform反向偏移 `transform: translate(-50%, -50%);`
	4. table 表布局，父元素:`display: table-cell; vertical-align: middle;`; 子元素: `margin: auto;`
	5. flex布局，父元素：`display: flex; align-items: center; justify-content: center;`;
***
### 二. Js基础
##### 1. Js的解析和执行过程
	- 关键词： 词法环境，预处理，执行，函数是第一成员，变量，命名冲突，
1. 全局预处理阶段和执行阶段
	- 全局预处理阶段只会把声明的函数，var声明的变量的名字放在词法环境（执行上下文）的对象中，值分别为指向函数的引用，undefined
	```javacript	
		{
			f: function f(){},
			a: undefined
		}
	```
2. 函数的预处理阶段：每调用一次，产生一个词法环境，扫描顺序依次是函数参数，内部声明式函数，内部var变量，解决冲突跟全局一样
3. 处理变量冲突时，直接忽略，处理函数冲突，会覆盖； 
	```javascript
		console.log(a);                         // function a( console.log(4) )
		function a(){ console.log(2); }
		console.log(a);                         // function a( console.log(4) )
		var a = 1								
		console.log(a);                         // 1
		var a = 3;
		console.log(a);                         // 3
		function a(){ console.log(4); }			
		console.log(a);                         // 3
		a();                                    // a is not a function
	```
![JS OOP](https://segmentfault.com/img/bVbe2UQ?w=1744&h=782)
##### 2. 作用域 
[作用域练习代码](#Js作用域)
1. 函数的作用域：函数被创建时，会有内部属性[[scope]]指向创建函数时的词法环境，等函数被调用执行，会创建自己的词法环境。
2. 作用域链
	1. 当声明一个函数时，局部作用域一级一级向上包起来，就是作用域链。
	2. 当执行函数时，总是先从函数内部找寻局部变量
	3. 如果内部找不到（函数的局部作用域没有），则会向创建函数的作用域（声明函数的作用域）寻找，依次向上
	4. 作用域链可以保证对执行环境有权访问的所有变量和函数的有序访问，有助于确定应该合适释放内存
3. 闭包
	1. 本质： js的作用域链导致闭包的产生；
	2. 定义： 携带自由变量的函数及其引用环境所构成的实体
		- 好处：实现封装，保证变量安全，减少全局变量。
		- 缺点：容易造成内存泄漏，因为闭包中的局部变量永远不会被回收
##### 3. 从Event Loop谈JS的运行机制
##### 4. 事件模型
##### 5. 通信类
##### 6. 安全类
***
### 三. 浏览器相关
##### 1. 浏览器的运行机制
##### 2. 浏览器渲染页面的原理及流程
##### 3. 浏览器存储
***
### 四. 性能优化相关
##### 1. 容错机制(报错监管)
##### 2. 资源合并
##### 3. 图片的懒加载与 预加载
##### 4. 重绘与回流

***
# 代码部分
#### css基础的三列布局
```css
/*1.float 中间的不设置宽度，第三个元素右浮动*/
	.wrap div{
		height: 100%;
	}
	.son1{
		float: left;
		width: 100px;
	}
	.son2{
		float: left;
	}
	.son3{
		float: right;
		width: 100px;
	}
/*2.position 中间自然敞开*/
	.wrap div{
		height: 100%;
		position: absolute;
	}
	.son1{
		left: 0;
		width: 100px;
	}
	.son2{
		left: 100px;
		right: 100px;
	}
	.son3{
		right: 0;
		width: 100px;
	}
/*3. 中间元素 width: calc( 100% - 已知)*/
/*4. flex */
	.wrap div{
		height: 100%;
	}
	.son1{
		width: 100px;
	}
	.son2{
		flex: 1;
	}
	.son3{
		width: 100px;
	}
/*5.table */
	.wrap {
		width: 500px;
		height: 300px;    
		display: table;
	}
	.wrap div{
		height: 100%;
		display: table-cell;
	}
	.son1{
		width: 100px;
	}
	.son3{
		width: 100px;
	}
/*6.网格布局*/
	.wrap {
		width: 700px;
		display: grid;
		grid-template-rows: 100px;              /*网格高度*/
		grid-template-columns: 300px auto 300px;/*三个网格的宽度*/
	}
```
#### Js作用域
```javascript
	//1. 作用域链，声明时确定
	var teacher = "jingyuan";
	function ask(question){
	 	console.log(teacher,question);
	}
	function other(){
	  	var teacher = "weiwei";
	  	ask("who");
	}
	other()   //'jingyuan','who'   
	
	// 2. this指向问题
	var workshop = {
   	teacher:"17dian",
		ask(){
			console.log(this.teacher,this.question)
		}
	}
	var teacher = "jingyuan";
	var question = "are you OK?"
	workshop.ask()  //'jingyuan',undefined
	
	//3. this指向
	var workshop = {
		teacher:"jingyuan",
		ask(question){
			setTimeout(function(){
				console.log(this)
			},100)      
		},
		arrowAsk(question){
			setTimeout(()=>{
				console.log(this)
			},100)      
		}
	}
	workshop.ask()  // Window对象
	workshop.arrowAsk() //workshop对象
	
	//4. 暂存性死区
	var teacher = "jingyuan";
	function otherClass(teacher){
   		if(typeof teacher === 'undefined'){
     		console.log(teacher)
     		let teacher = "dongyang"
		}else {
			console.log(teacher);
		}
	}
	otherClass()  //报错
	
	//5. 函数名，var变量提升。  以及表达式和函数式声明函数时，fn只能在函数内部使用。
	function fn(){
	  	return print()
	  	function print(){
			console.log('1')
	  	}
	}
	let fn2 = function fn(){
	  	console.log(fn)
	  	return print2()
	  	var print2 = function(){
			console.log('2')
	  	}
	}
	fn()   //1
	fn2()  //输出fn2函数体   print2 is not a function
```





































						
  
