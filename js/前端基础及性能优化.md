### 一. Css基础
##### 1. 盒模型
1. 盒模型是 （content），margin（外边距）、border（边框）、padding（内边框）
	1. IE盒模型的width: border+padding+content;
	2. 标准盒模型width: content;
	3. 改变盒模型： (IE)box-sizing: border-box； (普通)box-sizing: content-box;
2. 几种获取元素宽度的区别
	1. clientWidth: 包括内边距，不包括垂直滚动条(如果有的话)、边框和外边框;
	2. offsetWidth: border,padding,width的总和;
	3. scrollWidth: 实际内容的宽度+padding;
##### 2. BFC
1. BFC（Block Formatting Context）格式化上下文
2. 形成条件
	1. float的值不为none
	2. overflow的值不为visible
	3. position的值不为static；
	4. display的值为inline-blcok,table-cell,table-caption;
	5. flex boxes
3. 布局规则
	1. BFC就是页面上的一个独立容器，容器里面的子元素不会影响到外面的元素
	2. 同一个BFC的两个相邻盒子的margin可能会发生重叠
	3. BFC的区域不会与float元素区域重叠
	4. 计算BFC的高度时，浮动子元素也参与计算
4. 应用
	1.	解决margin重叠问题
	2.	解决浮动问题
	3.	解决侵占浮动元素的问题
##### 3. css布局
1. 三列布局，左右宽度已知，中间元素自动敞开，6种方式 [查看代码](#css基础的三列布局)
	1. float 中间不设置宽度;
	2. position 中间不设置宽度;
	3. flex 弹性盒子，设置父元素`display：flex`，中间设置为`flex:1`;
	3. calc 中间设置 `width: calc(100% - 200px)`;
	4. table 表布局，中间不设置宽度
	5. gird 网格布局
2. 水平垂直居中
	1. 绝对定位+margin：auto
	2. 绝对定位+margin反向偏移 `margin-left: -100px;  margin-top: -75px; `
	3. 绝对定位+transform反向偏移 `transform: translate(-50%, -50%);`
	4. table 表布局，父元素:`display: table-cell; vertical-align: middle;`; 子元素: `margin: auto;`
	5. flex布局，父元素：`display: flex; align-items: center; justify-content: center;`;
***
### 二. Js基础
##### 1. Js的解析和执行过程
	- 关键词： 词法环境，预处理，执行，函数是第一成员，变量，命名冲突，
1. 全局预处理阶段和执行阶段
	- 全局预处理阶段只会把声明的函数，var声明的变量的名字放在词法环境（执行上下文）的对象中，值分别为指向函数的引用，undefined
	```javacript	
		{
			f: function f(){},
			a: undefined
		}
	```
2. 函数的预处理阶段：每调用一次，产生一个词法环境，扫描顺序依次是函数参数，内部声明式函数，内部var变量，解决冲突跟全局一样
3. 处理变量冲突时，直接忽略，处理函数冲突，会覆盖； 
	```javascript
		console.log(a);                         // function a( console.log(4) )
		function a(){ console.log(2); }
		console.log(a);                         // function a( console.log(4) )
		var a = 1								
		console.log(a);                         // 1
		var a = 3;
		console.log(a);                         // 3
		function a(){ console.log(4); }			
		console.log(a);                         // 3
		a();                                    // a is not a function
	```
![JS OOP](https://segmentfault.com/img/bVbe2UQ?w=1744&h=782)
##### 2. 作用域 
[作用域练习代码](#Js作用域)
1. 函数的作用域：函数被创建时，会有内部属性[[scope]]指向创建函数时的词法环境，等函数被调用执行，会创建自己的词法环境。
2. 作用域链
	1. 当声明一个函数时，局部作用域一级一级向上包起来，就是作用域链。
	2. 当执行函数时，总是先从函数内部找寻局部变量
	3. 如果内部找不到（函数的局部作用域没有），则会向创建函数的作用域（声明函数的作用域）寻找，依次向上
	4. 作用域链可以保证对执行环境有权访问的所有变量和函数的有序访问，有助于确定应该合适释放内存
3. 闭包
	1. 本质： js的作用域链导致闭包的产生；
	2. 定义： 携带自由变量的函数及其引用环境所构成的实体
		> 1. 好处：实现封装，保证变量安全，减少全局变量。
		> 2. 缺点：容易造成内存泄漏，因为闭包中的局部变量永远不会被回收
##### 3. 事件模型
1. 事件模型：捕获 冒泡
2. 事件流：当用户出发一个事件，首先通过捕获从window->html->body->父级元素 到目标阶段，在经过冒泡->window对象
3. 事件：
	1. 添加事件  
		> - `dom.addEventListener() false- 默认。事件句柄在冒泡阶段执行`
		> - `element.attachEvent(event, function);`
		> - `element.detachEvent(event, function);`
	2.	自定义事件[发布订阅模式](https://github.com/oneonetwo/yjytable/blob/master/js/%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81.md#1-%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F)	
		> - `var eve = new Event(“eventName”)`
		> - `dom.addEventListener(“eventName”)`
		> - `dom.dispatchEvent(eve);`
	3. 事件对象
		> - `Ev.preventDefault()`
		> - `Ev.stopPropagation()`
		> - `Ev.stopImmediatePropagation()`  事件优先级
		> - `Ev.currentTarget()`
		> - `Ev.target()`

##### 4. 从Event Loop谈JS的运行机制

##### 5. 通信类
1. 前后端通信的几种方式
	1. Ajax(同源通信)
	2. [WebSocket(协议不同的不同源通信)](https://github.com/oneonetwo/yjytable/blob/master/http/point.md#http%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF)
	3. [CORS](https://github.com/oneonetwo/yjytable/blob/master/http/point.md#http%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF)(用于支持不同源之间ajax通信的方法)
	4. Sse服务器端推送
2. 跨域通讯的几种方式
	1. Jsonp缺点
		> - 缺点是安全性。万一假如提供jsonp的服务存在页面注入漏洞,它只支持GET请求而不支持POST等其它类型的HTTP请求
	2. Hash 利用window.onhashchange事件
	```javascript
		//当前页面A通过iframe嵌入到不同域的页面B
		//A中的伪代码
		let B = document.getElementsByTagName('iframe');
		B.src = `${B.src}#${data}`;
		// B中的伪代码；
		window.onhashchange = function(){
			let data = window.location.hash;
		}
	```
	3. PostMessage window.postMessage() 方法可以安全地实现跨源通信,兼容性问题
	```javascript
		//窗口A向不同域的窗口B发送信息
		BWindow.postMessage('data','http://b.com');
		Awindow.addEventListener('message', function(event){
			console.log(event.origin);//http://b.com
			console.log(event.source);//BWindow;
			console.log(event.data);//data
		})
	```
	4. webSocket
	5. cors: 缺点：CORS要求浏览器(>IE10)和服务器的同时支持
		> - fetch()基于 Promise 的提供了许多与XMLHttpRequest相同的功能，更具可扩展性和高效性

##### 6. 安全类
1. csrf cross-site-request-forgery 跨站请求伪造
	1. 原理： 
		> 1. 用户登录受信任网站A,返回cookie信息；在保持登录状态下，用户访问恶意网站B，网站B向网站A后台发送请求（携带A的cookie），恶意代码被执行； 
	2. 特征：
		> 1. 网站B向网站A后台发送请求，不经过网站A的前端
		> 2. 携带A网站的cookie
		> 3. referer,B网站 `HTTP 协议在请求（request）的头信息里面，设计了一个Referer字段，给出访问来源网页的URL。`。
	3. 防御措施： 根据特征
		> 1. 提交表单添加**动态验证码**；
		> 2. 请求地址添加**token**并验证
		> 3. 设置cookie的**samesite**，设置成“SameSite=Strict”可以严格限定 Cookie 不能随着链接跨站发送（只有chrome支持）
		> 4. 后台验证HTTP referer字段
2. xss cross-site-scripting 跨站脚本攻击
	1. 原理：
		> - 反射型，通过url参数直接带入script脚本；存储型，通过表单写入脚本并保存在数据库中
	2. 危害
		> - 操作页面数据，获取cookie，截取前端逻辑， 发送请求；
	3. 防御措施：
		> - 对用户输入和url参数进行过滤验证，编码；
***
### 三. 浏览器相关
##### 1. 浏览器的运行机制
##### 2. 浏览器渲染页面的原理及流程
##### 3. 浏览器存储
***
### 四. 性能优化相关
##### 1. 容错机制(报错监管)
##### 2. 资源合并
##### 3. 图片的懒加载与 预加载
##### 4. 重绘与回流

***
# 代码部分
#### css基础的三列布局
```css
/*1.float 中间的不设置宽度，第三个元素右浮动*/
	.wrap div{
		height: 100%;
	}
	.son1{
		float: left;
		width: 100px;
	}
	.son2{
		float: left;
	}
	.son3{
		float: right;
		width: 100px;
	}
/*2.position 中间自然敞开*/
	.wrap div{
		height: 100%;
		position: absolute;
	}
	.son1{
		left: 0;
		width: 100px;
	}
	.son2{
		left: 100px;
		right: 100px;
	}
	.son3{
		right: 0;
		width: 100px;
	}
/*3. 中间元素 width: calc( 100% - 已知)*/
/*4. flex */
	.wrap div{
		height: 100%;
	}
	.son1{
		width: 100px;
	}
	.son2{
		flex: 1;
	}
	.son3{
		width: 100px;
	}
/*5.table */
	.wrap {
		width: 500px;
		height: 300px;    
		display: table;
	}
	.wrap div{
		height: 100%;
		display: table-cell;
	}
	.son1{
		width: 100px;
	}
	.son3{
		width: 100px;
	}
/*6.网格布局*/
	.wrap {
		width: 700px;
		display: grid;
		grid-template-rows: 100px;              /*网格高度*/
		grid-template-columns: 300px auto 300px;/*三个网格的宽度*/
	}
```
#### Js作用域
```javascript
	//1. 作用域链，声明时确定
	var teacher = "jingyuan";
	function ask(question){
	 	console.log(teacher,question);
	}
	function other(){
	  	var teacher = "weiwei";
	  	ask("who");
	}
	other()   //'jingyuan','who'   
	
	// 2. this指向问题
	var workshop = {
   	teacher:"17dian",
		ask(){
			console.log(this.teacher,this.question)
		}
	}
	var teacher = "jingyuan";
	var question = "are you OK?"
	workshop.ask()  //'jingyuan',undefined
	
	//3. this指向
	var workshop = {
		teacher:"jingyuan",
		ask(question){
			setTimeout(function(){
				console.log(this)
			},100)      
		},
		arrowAsk(question){
			setTimeout(()=>{
				console.log(this)
			},100)      
		}
	}
	workshop.ask()  // Window对象
	workshop.arrowAsk() //workshop对象
	
	//4. 暂存性死区
	var teacher = "jingyuan";
	function otherClass(teacher){
   		if(typeof teacher === 'undefined'){
     		console.log(teacher)
     		let teacher = "dongyang"
		}else {
			console.log(teacher);
		}
	}
	otherClass()  //报错
	
	//5. 函数名，var变量提升。  以及表达式和函数式声明函数时，fn只能在函数内部使用。
	function fn(){
	  	return print()
	  	function print(){
			console.log('1')
	  	}
	}
	let fn2 = function fn(){
	  	console.log(fn)
	  	return print2()
	  	var print2 = function(){
			console.log('2')
	  	}
	}
	fn()   //1
	fn2()  //输出fn2函数体   print2 is not a function
```





































						
  
