# 设计模式概要
## 一. 软件设计与开发
##### 1. 软件生命周期
1. 可行性分析报告和软件开发计划
2. 需求分析 （分析师初步的需求制定和用户手册）
3. 软件设计（概要设计和详细设计）
4. 编码工作 （把设计编成编码）
5. 测试阶段 （白盒测试（单元测试）和 黑盒测试（功能测试））
6. 实施和维护工作 （实施工程师精心安装和配置，产出软件维护报告）
##### 2. 常用的开发方式
- 瀑布开发模型，增量开发模型，原型开发模型。

##### 3. 软件模型 （https://staruml.io/）
1. 用例图
    - 用例建模最主要的功能是表达系统的功能性需求或行为
    - 参与者：与系统交互的角色，可以是人也可以是事物或者其他系统
2. 类图
    - 描述类的静态结构，定义类以及描述类之间的关系： 关联，依赖，聚合，还包括类的属性和操作。
    - 类图包含7个元素
        - 类/Class、接口/Interface、协作/Collaboration、依赖关系/Dependency、泛化关系/generalization、关联关系/Association、实现关系/Realization。
        - 关联关系：
            1. 是依赖关系的特例，比依赖关系更强，导向性，具有多重性。1,0,0.1，n.m, m...;
        - 聚合关系：
            1. 聚合关系是关联关系的特例，表示的是整体和部分的关系；整体和部分是可以分开的；双方的生命周期都是独立的。
        - 组合关系：也是整体和部分的关系，但是整体和部分不可分开；整体和部分生命周期一致。
3. 对象图
    - 描述一组对象和他们之间的关系，某个时间的快照。
4. 活动图
    - 本质上就是流程图；描述系统的活动，判断系统的活动，判断点和分支等。
5. 时序图
    1. 强调的是消息时间顺序的交互图；
    2. 描述系统中类与类之间的交互，他将这些交互建模换成消息交换。
    3. 用于描述对象之间如何随着时间进行写作
    4. 时序图由活动者，对象，消息，生命线和控制焦点组成，
    5. 不同元素有不同的表示
6. 协作图
    1. 是时序图的一个变种、
    2. 时序图主要侧重的与对象间消息传递在时间上的先后关系，而协作图侧重与对象间以及对象与角色交互的静态关系。
7. 组件图
    1. 建立系统间各个组件之间的关系，他们是通过软件和文件组织在一起，使组件图可以帮助读者了解软件包的位置，以及各个版本包含哪些功能。
    2. 组件图可以用来帮助设计系统的整体架构。
8. 部署图
    1. 帮助读者了解软件呵呵组件运行硬件什么位置，以及这些硬件之间的关系。
    2. 节点：用来表示一种硬件，可以是服务器，计算机等。
    3. 通信关联：节点通过通信关联建立彼此的关系，采用从节点到节点绘制实线来表示关联。
## 二. 面向对象分析和设计
1. 把客观对象抽象成属性数据和对数据相关的操作，把内部细节和不相关的信息隐藏起来。
2. 把同一类型的客观对象的属性和操作绑定在一起，封装成类
3. 允许不同层次进行抽象，通过继承实现属性和操作的共享。
4. 软件开发经历分析、设计、和编码三个阶段：
    - 面向对象的分析OOA (object oriented analysis)
    - 面向对象的设计OOD (object oriented design)
    - 面向对象的编程OOP(bject Oriented Programming)
5. 特性
    1. 继承
        - 子类继承父类，继承可以把公共方法抽象出来，提高复用，减少冗余
    2. 封装
        - 把数据封装起来，减少耦合，不该让外部访问的不让外部访问。
        - 利于数据的接口权限管理
        - 实现：
            1. public 公有
            2. protected: 受保护的, 只能在类和子类中访问，实例不能访问。
            3. private: 私有，只能在类中访问。
    3. 多态
        - 同一个接口有不同的实现。
        - 保持子类的开放性和灵活性
        - 面向接口编程
## 三. 设计原则 SOLID
    1. 五大原则
        - S 单一职责原则(single responsibility principle)
            - 对象应该具有一种单一功能的概念， 如果功能复杂则进行拆分。
        - O 开放封闭原则（Open Closed Principle）
            - 软件应该是对于扩展开放，但是对于修改封闭的概念。
        - L 里氏替换原则（Liskov Substitution Principle）
            - 子类能否覆盖父类，父类能出现的地方子类就能出现
        - D 依赖倒置原则（Dependence Inversion Principle） 
            - 面向接口编程，依赖于抽象并非具体的实现。
            - 使用方只关注接口不关注具体类的实现。
        - I 接口隔离原则（interface Segregation Principle）
            - 保持接口的单一独立，避免实现胖接口。
    2. 迪米特法则
    3. 合成复用原则
    4. 总结：开闭原则是核心，单一原子紧跟随，里氏替换要抽象，依赖倒置看接口，接口隔离防守好。
        - 开闭原则是核心，对修改关闭对扩展发放是软件设计的基石。
        - 单一职责要求我们设计接口和模块的时候尽量保证单一性和原子性，修改一条不影响全局和其他模块。
        - 里氏替换原则和依赖倒置原则要求面向接口和抽象编程，都这实现一改，上层调用者就要对应修改。
    5. 如何写出来好代码
        - 可维护行BUG是否好改。
        - 可读性是否容易看懂
        - 可扩展性 是否可以添加新功能
        - 灵活性 添加新功能是否容易，老方法和接口是否容易复用
        - 简洁性 代码是否简单清晰
        - 可复用性 相同的代码不用写多次
        - 可测试性 是否方便些单元测试和集成测试

## 四. 23种设计模式 
1. 23 种经典的设计模式分为三类：创建型、结构型、行为型
    - 创建型设计模式主要解决“对象的创建”问题，结构型设计模式主要解决“类或对象的组合或组装”问题，那行为型设计模式主要解决的就是“类或对象之间的交互”问题。
2. 创建型：
3. 结构型：
4. 行为型：观察者模式、模板模式、策略模式、职责链模式、状态模式、迭代器模式、访问者模式、备忘录模式、命令模式、解释器模式、中介模式。

## 工厂模式 (Factory Design Pattern)
1. 定义：
    - 工厂模式分为三种更加细分的类型：简单工厂、工厂方法和抽象工厂;
    - 当创建逻辑比较复杂，是一个“大工程”的时候，我们就考虑使用工厂模式，封装对象的创建过程，将对象的创建和使用相分离。
    - 什么时候该用工厂模式？相对于直接 new 来创建对象，用工厂模式来创建究竟有什么好处呢？
    - 第一种情况：类似规则配置解析的例子，代码中存在 if-else 分支判断，动态地根据不同的类型创建不同的对象。针对这种情况，我们就考虑使用工厂模式，将这一大坨 if-else 创建对象的代码抽离出来，放到工厂类中。
    - 还有一种情况，尽管我们不需要根据不同的类型创建不同的对象，但是，单个对象本身的创建过程比较复杂，比如前面提到的要组合其他类对象，做各种初始化操作。在这种情况下，我们也可以考虑使用工厂模式，将对象的创建过程封装到工厂类中。
2. 实现：
    - 简单工厂： 简单工厂就是一个工厂对象决定创建哪种产品类的实例，就是函数返回一个需要的类的实现。
    - 工厂方法： 工厂方法模式就是核心工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类去做
    - 抽象工厂模式：
        - 1. 抽象工厂模式可以向客户端提供一个接口，使客户端不必指定产品的具体类型的情况下，创建多个产品组中的产品对象。
        - 2. 工厂方法模式针对的是同一类或者统一登记产品，而抽象工厂模式针对的是多种类的产品设计。
        - 3. 系统中有多个产品组，每个具体工厂负责创建同一族但不同类型的产品。
    - 在简单工厂里面，由工厂创建产品。而在工厂方法中又是有工厂创建产品，先创建具体的工厂，再由具体的工厂去创建产品。
3. 应用：
    - jQuery的实例的创建就是一个简单工厂。https://github.com/jquery/jquery/blob/main/src/core.js
    - React.CreateElement也是简单工厂的应用。https://github.com/facebook/react/blob/main/packages/react/src/ReactElement.js
    - CreateFactory是对工厂方法的应用。https://github.com/facebook/react/blob/main/packages/react/src/ReactElement.js
## 单例模式 (Singleton Design Pattern)
1. 定义：一个类只能创建一个实例，那么这个类就是单例类。
2. 实现方式：
    - 1. 把生成的实例挂载到类的私有属性上， 通过每次调用静态方法生成单例。
    - 2. 透明单例,用户正常new,并不知道是个单例类。
    - 3. 单例的构建与类分类
    - 4. 单例封装变化，可以创建任何沟槽函数实例。
    - 5. 如何创建一个多例模式
        - “单例”指的是一个类只能创建一个对象。对应地，“多例”指的就是一个类可以创建多个对象，但是个数是有限制的，比如只能创建 3 个对象。多例的实现也比较简单，通过一个 Map 来存储对象类型和对象之间的对应关系，来控制对象的个数。
3. 应用
    - commonJS的应用，JQuery的引用， Modal模态框, store, express的用户缓存。
4. 问题：
    - 单例对 OOP 特性的支持不友好
    - 单例会隐藏类之间的依赖关系
    - 单例对代码的扩展性不友好
    - 单例对代码的可测试性不友好
    - 单例不支持有参数的构造函数

## 适配器模式 (Adaptor Design Pattern)
1. 定义： 
    - 1. 适配器模式又称包装器模式，将一个接口转化为用户需要的另一个接口，主要是解决类之前接口不兼容的问题。
    - 2. 适配器模式有两种实现方式：类适配器和对象适配器
2. 实现：
    - 1. 类适配器使用继承关系来实现
    - 2. 对象适配器使用组合关系来实现
3. 应用：
    - axios的兼容处理。promisify的实现。

## 裝飾器模式(Decorator Design Parrern)
1. 特点：
    - 1. 在不改变原有的结构和功能的情况下，为对象添加新的功能的模式。
    - 2. 装饰器比继承更加的灵活，可以实现装饰者和被装饰者的松耦合。
    - 3. 被装饰者可以使用装饰者动态的增加和撤销功能。
2. 实现：在设计的时候，装饰器类需要跟原始类继承相同的抽象类或者接口。
3. 应用：readonly  埋点   redux的connect的实现   提交表单, 防抖，节流。
4. AOP（Aspect Oriented Programming）面向切面编程
    1. 可以通过预编译方式和运行期动态代理实现不修改源代码的情况下给程序动态统一添加功能的一种技术。

## 代理模式(Proxy Design Pattern)
1. 定义：
    - 它在不改变原始类的情况下，通过代理类给原始类附加功能。
    - 由于一个对象不能直接引用另一个对象，所以需要通过代理对象在这两个对象之间起到中介作用
    - 
2. 实现： 
    - 代理模式就是为目标对象创建一个代理对象，已实现对目标对象的访问。
    - 代理模式的原理与实现： 一般情况下，我们让代理类和原始类实现同样的接口。但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的。在这种情况下，我们可以通过让代理类继承原始类的方法来实现代理模式。
    - 动态代理的原理与实现： 静态代理需要针对每个类都创建一个代理类，并且每个代理类中的代码都有点像模板式的“重复”代码，增加了维护成本和开发成本。对于静态代理存在的问题，我们可以通过动态代理来解决。我们不事先为每个原始类编写代理类，而是在运行的时候动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。
3. 应用： 
    - 事件委托代理： 事件捕获指的是从document触发时间的那个节点，既自上而下的触发事件。 事件冒泡是自下而上的触发事件。 绑定方法的第三个参数，控制事件触发的顺序是否为事件捕获，true为事件捕获，false为事件冒泡。
    - 图片的懒加载  Element.getBoundingCientRect() 提供了元素的大小以及相对于视口的位置。
    - 缓存代理
    - 节流防抖
    - 代理跨域
        - 1. 正向代理和反向代理
            - 正向代理的对象是客户端，服务器看不到真正的客户端， 比如公司的代理服务器。
            - 反向代理是对象的服务端，客户端看不到服务端。 比如nginx服务器
    - ES6 proxy的set get属性劫持

## 观察者模式
1. 定义： 观察者定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个对象的状态发生改变时，它能够自动更新。
2. 发布订阅模式的区别
    1. 订阅者把自己订阅的事件注册到调度中心
    2. 当该事件触发的时候，发布者发布该事件到调度中心统一调度订阅者注册的处理代码
    3. 虽然两种模式都纯存在订阅者和发布者， 但是观察者模式由订阅者调度，发布订阅模式由调度中心统一处理。
    4. 所以观察者模式两者之间是存在依赖的，而发布订阅模式则不会。
3. 场景：
    - 1. Dom绑定事件
    - 2. Promise的回调函数收集
    - 3. JQuery.Callbacks用来进行函数队列的add、remove、fire、lock等操作
    - 4. 自定义事件
    - 5. Vue的eventBus, 响应式原理
    - 6. redux
    - 7. redis 的发布订阅

## 外观模式 (Facede Design Pattern)
1. 定义：
    - 1. 外观模式又称为门面模式，为子系统提供一组统一的接口，定义一组高层接口让子系统更易用。
    - 2. 外观模式让外界减少与子系统内多个模块的直接交互，从而减少耦合，让外界可以更轻松的使用子系统
2. 实现：
    - 1. 该设计模式下的角色组成：
    - 门面角色：外观模式的核心。然被客户角色调用，它熟悉子系统的功能，他根据客户需求预定了几种功能的组合。
    - 子系统角色：实现了子系统的功能，他对客户角色和Facade是未知的
    - 客户角色：通过调用Facade来满足需求。
3. 应用： 计算器，解压缩，中间件。

## 迭代器模式（Iterator Design Patter）
1. 用来遍历集合对象。 
2. 迭代器模式(n）)用于顺序的访问聚合对象内部的元素，又无需知道对象内部结构。使用了迭代器之后，使用者不需要关心对象的内部构造，就可以按需访问每个元素。
**TODO: 復習async await generator的實現原理** 


## 状态模式（State Machine）
1. 定义：当一个对象的内部状态发生改变时，会导致其行为的改变，对象有自己的状态，不同状态下执行的逻辑不一样，明确状态和每个状态下执行的动作
2. 实现：
    1. 分支逻辑法：利用 if-else 或者 switch-case 分支逻辑，参照状态转移图，将每一个状态转移原模原样地直译成代码。对于简单的状态机来说，这种实现方式最简单、最直接，是首选。
    2. 查表法：对于状态很多、状态转移比较复杂的状态机来说，查表法比较合适。通过二维数组来表示状态转移图，能极大地提高代码的可读性和可维护性。
    3. 状态模式: 对于状态并不多、状态转移也比较简单，但事件触发执行的动作包含的业务逻辑可能比较复杂的状态机来说，我们首选这种实现方式。
3. 应用：
    1. 状态模式一版用来实现状态机，状态机常用在游戏，工作流引擎等系统开发中。
    2. 有限状态机的库 javascript-state-machine  https://github.com/jakesgordon/javascript-state-machine
    3. css动画https://juejin.cn/post/6844903745696825358

## 策略模式（Strategy Design Pattern）
1. 原理：
    1. 定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）
    2. 工厂模式是解耦对象的创建和使用，观察者模式是解耦观察者和被观察者。策略模式跟两者类似，也能起到解耦的作用，不过，它解耦的是策略的定义、创建、使用这三部分
2. 实现： 策略模式用来解耦策略的定义、创建、使用。实际上，一个完整的策略模式就是由这三个部分组成的。
    1. 策略类的定义比较简单，包含一个策略接口和一组实现这个接口的策略类。
    2. 策略的创建由工厂类来完成，封装策略创建的细节。
    3. 策略模式包含一组策略可选，客户端代码如何选择使用哪个策略，有两种确定方法：编译时静态确定和运行时动态确定。其中，“运行时动态确定”才是策略模式最典型的应用场景。
3. 应用：
    

## 原型模式
1. 原型模式是一种创建型模式。
2. 创建基类的时候，简单差异化的属性放在构造函数中，公用的函数放在基类原型中。
3. `Instanceof`运算符的第一个变量是一个对象，暂时称为A；第二个变量一般是一个函数，暂时称为B

## 桥接模式
1. 将抽象部分与他的实现部分分离，这样抽象化与实现化解耦，是他可以独立的变化。
2. 应用场景是实现系统可能多个角度分类，每一种角度都可能变化。
3. 桥方可以通过实现桥接口进行单方面扩展，而另一方可以继承抽象类而单方面扩展，而之间的调用就从桥接口来作为突破口，不会受到双方扩展的任何影响

## 组合模式
1. 将对象组合成树形结构以表示部分-整体的层次结构。
2. 客户可以使用统一的方式对待组合对象和叶子对象。
    

## 命令模式
1. 命令模式将请求（命令）封装成一个对象，这样可以使用不同的请求参数化其他对象（将不同请求依赖注入到其他对象），并且能够支持请求（命令）的排队执行、记录日志、撤销等（附加控制）功能。
2. 落实到编码，命令模式用的最核心的实现手段，是将函数封装成对象。具体来说就是设计一个包含这个函数的类，实例化一个对象传来传去，这样就可以实现把函数像对象一样使用。
3. 当我们把函数封装成对象之后，对象就可以存储下来，方便控制执行。
4. 命令模式的主要作用和应用场景，是用来控制命令的执行，比如，异步、延迟、排队执行命令、撤销重做命令、存储命令、给命令记录日志等。这才是命令模式发挥独一无二的地方。

## 享元模式（Flyweight Design Pattern）
1. 所谓“享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。
2. 具体来讲，当一个系统中存在大量重复对象的时候，如果这些重复的对象是不可变对象，我们就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码引用。这样可以减少内存中对象的数量，起到节省内存的目的。
3. 实际上，不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分（字段）提取出来，设计成享元，让这些大量相似对象引用这些享元。
4. 这里我稍微解释一下，定义中的“不可变对象”指的是，一旦通过构造函数初始化完成之后，它的状态（对象的成员变量或者属性）就不会再被修改了。所以，不可变对象不能暴露任何 set() 等修改内部状态的方法。之所以要求享元是不可变对象，那是因为它会被多处代码共享使用，避免一处代码对享元进行了修改，影响到其他使用它的代码。

## 模板模式（Template Design Patter）
1. 模板方法模式在一个方法中定义一个算法的骨架，而将一些步骤的实现延迟到子类中
2. 模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中某些步骤的具体实现
3. 一般有两部分组成，第一部分是抽象父类，第二部分是具体的实现子类
4. 好莱坞原则，子类放弃了控制权，改由父类来调用
5. 应用：发布订阅，回调函数


