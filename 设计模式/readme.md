<!--
 * @Description: 
 * @Author: yjy
 * @Date: 2023-02-21 21:51:11
 * @LastEditTime: 2023-03-10 09:52:57
 * @LastEditors: jy
 * @Reference: 
-->
# 设计模式概要
## 一. 软件设计与开发
    1. 软件生命周期
        1. 可行性分析报告和软件开发计划
        2. 需求分析
        3，软件设计（概要设计和详细设计）
        4. 编码工作
        5. 测试阶段
        6. 实施和维护工作
    2. 软件模型
        1. 用例图
        2. 类图
        3. 对象图
        4. 活动图
        5. 时序图
        6. 协作图
        7. 组件图
        8. 部署图
## 二. 面向对象分析和设计
## 三. 设计原则 SOLID
    1. 五大原则
        - S 单一职责原则
        - O 开放封闭原则
        - L 里氏替换原则
        - D 依赖倒置原则: 依赖抽象并非具体的实现。
        - I 接口隔离原则：保持接口的单一独立，避免实现胖接口。
    2. 迪米特法则
    3. 合成复用原则
    4. 总结：开闭原则是核心，单一原子紧跟随，里氏替换要抽象，依赖倒置看接口，接口隔离防守好。
        - 开闭原则是核心，对修改关闭对扩展发放是软件设计的基石。
        - 单一职责要求我们设计接口和模块的时候尽量保证单一性和原子性，修改一条不印象全局和其他模块。
        - 里氏替换原则和依赖倒置原则要求面向接口和抽象编程，都这实现一改，上层调用者就要对应修改。
    5. 如何写出来好代码
        - 可维护行BUG是否好改。
        - 可读性是否容易看懂
        - 可扩展性 是否可以添加新功能
        - 灵活性 添加新功能是否容易，老方法和接口是否容易复用
        - 简洁性 代码是否简单清晰
        - 可复用性 相同的代码不用写多次
        - 可测试性 是否方便些单元测试和集成测试

## 四. 23种设计模式 

## 适配器模式
1. 适配器模式又称包装器模式，将一个接口转化为用户需要的另一个接口，主要是解决类之前接口不兼容的问题。

## 裝飾器模式
1. 在不改变原有的结构和功能的情况下为对象添加新功能的模式
2. 
3. 应用: readonly  埋点   redux的connect的实现   提交表单

## 代理模式
1. 由于一个对象不能直接引用另一个对象，所以需要通过代理对象在这两个对象之间起到中介作用。
2. 代理模式就是为目标对象创建一个代理对象，已实现对目标对象的访问。

## 观察者模式
1. 观察者定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个对象的状态发生改变时，它能够自动更新。
2. 应用场景：绑定事件。
3. 发布订阅模式的区别
    1. 订阅者把自己订阅的事件注册到调度中心
    2. 当该事件触发的时候，发布者发布该事件到调度中心统一调度订阅者注册的处理代码
    3. 虽然两种模式都纯存在订阅者和发布者， 但是观察者模式由订阅者调度，发布订阅模式由调度中心统一处理。
    4. 所以观察者模式两者之间是存在依赖的，而发布订阅模式则不会。

## 外观模式
1. 外观模式又称为门面模式，定义一个将子系统的一组接口集成在一起的高层接口，以提供一个一致的外观。
2. 外观模式让外界减少与子系统内多个模块的直接交互，从而减少耦合，让外界可以更轻松的使用子系统
3. 该设计模式下的角色组成：
    - 门面角色：外观模式的核心。然被客户角色调用，它熟悉子系统的功能，他根据客户需求预定了几种功能的组合。
    - 子系统角色：实现了子系统的功能，他对客户角色和Facade是未知的
    - 客户角色：通过调用Facade来满足需求。

## 迭代器模式（Iterator Design Patter）
1. 用来遍历集合对象。 
2. 迭代器模式(n）)用于顺序的访问聚合对象内部的元素，又无需知道对象内部结构。使用了迭代器之后，使用者不需要关心对象的内部构造，就可以按需访问每个元素。
**TODO: 復習async await generator的實現原理** 


## 状态模式（State Machine）
1. 当一个对象的内部状态发生改变时，会导致其行为的改变，对象有自己的状态，不同状态下执行的逻辑不一样，明确状态和每个状态下执行的动作
2. 状态模式一版用来实现状态机，状态机常用在游戏，工作流引擎等系统开发中。

## 策略模式（Strategy Design Pattern）
1. 定义一族算法类，将每个算法分别封装起来，让他们可以相互替换。策略模式可以时算法的变化独立于他们使用者。
2. 解耦的是策略的定义，创建，使用者三部分， 避免大量的if else 或 swith case

## 原型模式
1. 原型模式是一种创建型模式。
2. 创建基类的时候，简单差异化的属性放在构造函数中，公用的函数放在基类原型中。

## 桥接模式
1. 将抽象部分与他的实现部分分离，这样抽象化与实现化解耦，是他可以独立的变化。
2. 应用场景是实现系统可能多个角度分类，每一种角度都可能变化。
3. 桥方可以通过实现桥接口进行单方面扩展，而另一方可以继承抽象类而单方面扩展，而之间的调用就从桥接口来作为突破口，不会受到双方扩展的任何影响

## 组合模式
1. 将对象组合成树形结构以表示部分-整体的层次结构。
2. 客户可以使用统一的方式对待组合对象和叶子对象。
    

## 命令模式
1. 命令模式将请求（命令）封装成一个对象，这样可以使用不同的请求参数化其他对象（将不同请求依赖注入到其他对象），并且能够支持请求（命令）的排队执行、记录日志、撤销等（附加控制）功能。
2. 落实到编码，命令模式用的最核心的实现手段，是将函数封装成对象。具体来说就是设计一个包含这个函数的类，实例化一个对象传来传去，这样就可以实现把函数像对象一样使用。
3. 当我们把函数封装成对象之后，对象就可以存储下来，方便控制执行。
4. 命令模式的主要作用和应用场景，是用来控制命令的执行，比如，异步、延迟、排队执行命令、撤销重做命令、存储命令、给命令记录日志等。这才是命令模式发挥独一无二的地方。

## 享元模式（Flyweight Design Pattern）
1. 所谓“享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。
2. 具体来讲，当一个系统中存在大量重复对象的时候，如果这些重复的对象是不可变对象，我们就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码引用。这样可以减少内存中对象的数量，起到节省内存的目的。
3. 实际上，不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分（字段）提取出来，设计成享元，让这些大量相似对象引用这些享元。
4. 这里我稍微解释一下，定义中的“不可变对象”指的是，一旦通过构造函数初始化完成之后，它的状态（对象的成员变量或者属性）就不会再被修改了。所以，不可变对象不能暴露任何 set() 等修改内部状态的方法。之所以要求享元是不可变对象，那是因为它会被多处代码共享使用，避免一处代码对享元进行了修改，影响到其他使用它的代码。





