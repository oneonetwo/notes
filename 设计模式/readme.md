<!--
 * @Description: 
 * @Author: yjy
 * @Date: 2023-02-21 21:51:11
 * @LastEditTime: 2023-03-13 20:30:54
 * @LastEditors: jy
 * @Reference: 
-->
# 设计模式概要
## 一. 软件设计与开发
#####1. 软件生命周期
1. 可行性分析报告和软件开发计划
2. 需求分析 （分析师初步的需求制定和用户手册）
3. 软件设计（概要设计和详细设计）
4. 编码工作 （把设计编成编码）
5. 测试阶段 （白盒测试（单元测试）和 黑盒测试（功能测试））
6. 实施和维护工作 （实施工程师精心安装和配置，产出软件维护报告）
#####2. 常用的开发方式
- 瀑布开发模型，增量开发模型，原型开发模型。

#####3. 软件模型 （https://staruml.io/）
1. 用例图
    - 用例建模最主要的功能是表达系统的功能性需求或行为
    - 参与者：与系统交互的角色，可以是人也可以是事物或者其他系统
2. 类图
    - 描述类的静态结构，定义类以及描述类之间的关系： 关联，依赖，聚合，还包括类的属性和操作。
    - 类图包含7个元素
        - 类/Class、接口/Interface、协作/Collaboration、依赖关系/Dependency、泛化关系/generalization、关联关系/Association、实现关系/Realization。
        - 关联关系：
            1. 是依赖关系的特例，比依赖关系更强，导向性，具有多重性。1,0,0.1，n.m, m...;
        - 聚合关系：
            1. 聚合关系是关联关系的特例，表示的是整体和部分的关系；整体和部分是可以分开的；双方的生命周期都是独立的。
        - 组合关系：也是整体和部分的关系，但是整体和部分不可分开；整体和部分生命周期一致。
3. 对象图
    - 描述一组对象和他们之间的关系，某个时间的快照。
4. 活动图
    - 本质上就是流程图；描述系统的活动，判断系统的活动，判断点和分支等。
5. 时序图
    1. 强调的是消息时间顺序的交互图；
    2. 描述系统中类与类之间的交互，他将这些交互建模换成消息交换。
    3. 用于描述对象之间如何随着时间进行写作
    4. 时序图由活动者，对象，消息，生命线和控制焦点组成，
    5. 不同元素有不同的表示
6. 协作图
    1. 是时序图的一个变种、
    2. 时序图主要侧重的与对象间消息传递在时间上的先后关系，而协作图侧重与对象间以及对象与角色交互的静态关系。
7. 组件图
    1. 建立系统间各个组件之间的关系，他们是通过软件和文件组织在一起，使组件图可以帮助读者了解软件包的位置，以及各个版本包含哪些功能。
    2. 组件图可以用来帮助设计系统的整体架构。
8. 部署图
    1. 帮助读者了解软件呵呵组件运行硬件什么位置，以及这些硬件之间的关系。
    2. 节点：用来表示一种硬件，可以是服务器，计算机等。
    3. 通信关联：节点通过通信关联建立彼此的关系，采用从节点到节点绘制实线来表示关联。
## 二. 面向对象分析和设计
1. 把客观对象抽象成属性数据和对数据相关的操作，把内部细节和不相关的信息隐藏起来。
2. 把同一类型的客观对象的属性和操作绑定在一起，封装成类
3. 允许不同层次进行抽象，通过继承实现属性和操作的共享。
4. 分三步：
    - 面向对象的分析OOA (object oriented analysis)
    - 面向对象的设计OOD (object oriented design)
    - 面向对象的编程OOP(bject Oriented Programming)
5. 特性
    1. 继承
        - 子类继承父类，继承可以把公共方法抽象出来，提高复用，减少冗余
    2. 封装
        - 把数据封装起来，减少耦合，不该让外部访问的不让外部访问。
        - 利于数据的接口权限管理
        - 实现：
            1. public 公有
            2. protected: 受保护的, 只能在类和子类中访问，实例不能访问。
            3. private: 私有，只能在类中访问。
    3. 多态
        - 同一个接口有不同的实现。
        - 保持子类的开放性和灵活性
        - 面向接口编程
## 三. 设计原则 SOLID
    1. 五大原则
        - S 单一职责原则(single responsibility principle)
            - 对象应该具有一种单一功能的概念， 如果功能复杂则进行拆分。
        - O 开放封闭原则（Open Closed Principle）
            - 软件应该是对于扩展开放，但是对于修改封闭的概念。
        - L 里氏替换原则（Liskov Substitution Principle）
            - 子类能否覆盖父类，父类能出现的地方子类就能出现
        - D 依赖倒置原则（Dependence Inversion Principle） 
            - 面向接口编程，依赖于抽象并非具体的实现。
            - 使用方只关注接口不关注具体类的实现。
        - I 接口隔离原则（interface Segregation Principle）
            - 保持接口的单一独立，避免实现胖接口。
    2. 迪米特法则
    3. 合成复用原则
    4. 总结：开闭原则是核心，单一原子紧跟随，里氏替换要抽象，依赖倒置看接口，接口隔离防守好。
        - 开闭原则是核心，对修改关闭对扩展发放是软件设计的基石。
        - 单一职责要求我们设计接口和模块的时候尽量保证单一性和原子性，修改一条不影响全局和其他模块。
        - 里氏替换原则和依赖倒置原则要求面向接口和抽象编程，都这实现一改，上层调用者就要对应修改。
    5. 如何写出来好代码
        - 可维护行BUG是否好改。
        - 可读性是否容易看懂
        - 可扩展性 是否可以添加新功能
        - 灵活性 添加新功能是否容易，老方法和接口是否容易复用
        - 简洁性 代码是否简单清晰
        - 可复用性 相同的代码不用写多次
        - 可测试性 是否方便些单元测试和集成测试

## 四. 23种设计模式 

## 适配器模式
1. 适配器模式又称包装器模式，将一个接口转化为用户需要的另一个接口，主要是解决类之前接口不兼容的问题。

## 裝飾器模式
1. 在不改变原有的结构和功能的情况下为对象添加新功能的模式
2. 
3. 应用: readonly  埋点   redux的connect的实现   提交表单

## 代理模式
1. 由于一个对象不能直接引用另一个对象，所以需要通过代理对象在这两个对象之间起到中介作用。
2. 代理模式就是为目标对象创建一个代理对象，已实现对目标对象的访问。

## 观察者模式
1. 观察者定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个对象的状态发生改变时，它能够自动更新。
2. 应用场景：绑定事件。
3. 发布订阅模式的区别
    1. 订阅者把自己订阅的事件注册到调度中心
    2. 当该事件触发的时候，发布者发布该事件到调度中心统一调度订阅者注册的处理代码
    3. 虽然两种模式都纯存在订阅者和发布者， 但是观察者模式由订阅者调度，发布订阅模式由调度中心统一处理。
    4. 所以观察者模式两者之间是存在依赖的，而发布订阅模式则不会。

## 外观模式
1. 外观模式又称为门面模式，定义一个将子系统的一组接口集成在一起的高层接口，以提供一个一致的外观。
2. 外观模式让外界减少与子系统内多个模块的直接交互，从而减少耦合，让外界可以更轻松的使用子系统
3. 该设计模式下的角色组成：
    - 门面角色：外观模式的核心。然被客户角色调用，它熟悉子系统的功能，他根据客户需求预定了几种功能的组合。
    - 子系统角色：实现了子系统的功能，他对客户角色和Facade是未知的
    - 客户角色：通过调用Facade来满足需求。

## 迭代器模式（Iterator Design Patter）
1. 用来遍历集合对象。 
2. 迭代器模式(n）)用于顺序的访问聚合对象内部的元素，又无需知道对象内部结构。使用了迭代器之后，使用者不需要关心对象的内部构造，就可以按需访问每个元素。
**TODO: 復習async await generator的實現原理** 


## 状态模式（State Machine）
1. 当一个对象的内部状态发生改变时，会导致其行为的改变，对象有自己的状态，不同状态下执行的逻辑不一样，明确状态和每个状态下执行的动作
2. 状态模式一版用来实现状态机，状态机常用在游戏，工作流引擎等系统开发中。

## 策略模式（Strategy Design Pattern）
1. 定义一族算法类，将每个算法分别封装起来，让他们可以相互替换。策略模式可以时算法的变化独立于他们使用者。
2. 解耦的是策略的定义，创建，使用者三部分， 避免大量的if else 或 swith case

## 原型模式
1. 原型模式是一种创建型模式。
2. 创建基类的时候，简单差异化的属性放在构造函数中，公用的函数放在基类原型中。

## 桥接模式
1. 将抽象部分与他的实现部分分离，这样抽象化与实现化解耦，是他可以独立的变化。
2. 应用场景是实现系统可能多个角度分类，每一种角度都可能变化。
3. 桥方可以通过实现桥接口进行单方面扩展，而另一方可以继承抽象类而单方面扩展，而之间的调用就从桥接口来作为突破口，不会受到双方扩展的任何影响

## 组合模式
1. 将对象组合成树形结构以表示部分-整体的层次结构。
2. 客户可以使用统一的方式对待组合对象和叶子对象。
    

## 命令模式
1. 命令模式将请求（命令）封装成一个对象，这样可以使用不同的请求参数化其他对象（将不同请求依赖注入到其他对象），并且能够支持请求（命令）的排队执行、记录日志、撤销等（附加控制）功能。
2. 落实到编码，命令模式用的最核心的实现手段，是将函数封装成对象。具体来说就是设计一个包含这个函数的类，实例化一个对象传来传去，这样就可以实现把函数像对象一样使用。
3. 当我们把函数封装成对象之后，对象就可以存储下来，方便控制执行。
4. 命令模式的主要作用和应用场景，是用来控制命令的执行，比如，异步、延迟、排队执行命令、撤销重做命令、存储命令、给命令记录日志等。这才是命令模式发挥独一无二的地方。

## 享元模式（Flyweight Design Pattern）
1. 所谓“享元”，顾名思义就是被共享的单元。享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。
2. 具体来讲，当一个系统中存在大量重复对象的时候，如果这些重复的对象是不可变对象，我们就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码引用。这样可以减少内存中对象的数量，起到节省内存的目的。
3. 实际上，不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分（字段）提取出来，设计成享元，让这些大量相似对象引用这些享元。
4. 这里我稍微解释一下，定义中的“不可变对象”指的是，一旦通过构造函数初始化完成之后，它的状态（对象的成员变量或者属性）就不会再被修改了。所以，不可变对象不能暴露任何 set() 等修改内部状态的方法。之所以要求享元是不可变对象，那是因为它会被多处代码共享使用，避免一处代码对享元进行了修改，影响到其他使用它的代码。

## 模板模式（Template Design Patter）
1. 模板方法模式在一个方法中定义一个算法的骨架，而将一些步骤的实现延迟到子类中
2. 模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中某些步骤的具体实现
3. 一般有两部分组成，第一部分是抽象父类，第二部分是具体的实现子类
4. 好莱坞原则，子类放弃了控制权，改由父类来调用
5. 应用：发布订阅，回调函数


